\chapter{Praktiskais}

\section{Git}

\section{RaspberryPi sagatavošana}
Lai sāktu lietot RaspberryPi, jāuzstāda kāds no pieejamo operētājsistēmu attēliem uz SD kartes. Uz RaspberryPi iespējams uzstādīt vairākas operētājsistēmas. Oficiāli atbalstīto Raspbian, kas ir uz Debian bāzēta Linux distribūcija, kas pielāgota RaspberryPi, pieejama arī Ubuntu Mate, Snappy Ubuntu Core, Windows 10 IOT Core un citas operētājsistēmas. Visas pieejamās un atbalstītās operētājsistēmas ir iespējams apskatīt \url{https://www.raspberrypi.org/downloads/}.
Darbā uzstādīta oficiāli atbalstītā Raspbian operētājsistēma. Tā ir pieejama ar vai bez grafiskās saskarnes un tika izvēlēts uzstādīt Lite versiju, kas ir bez grafiskās saskarnes, jo tā nav nepieciešama.

\subsubsection{Raspbian Jessie Lite uzstādīšana}
Pirms uzstādīšanas jāsarūpē SD karte, kurā ir pietiekami daudz brīvas vietas izvēlētajam operētājsistēmas attēlam un vēlāk uzstādītajām programmām. Kā arī jāņem vērā, ka pēc iespējas augstākas klases (jo ātrāka) SD karte, jo labāk. Rasbian operētājsistēma tika uzstādīta uz 8GB Class10 SD kartes, kas nodrošina secīgu datu ierakstīšanu ar, kā minimums, 10MB/s ātrumu.

Operētājsistēmas uzstādīšana uz SD kartes tika veikta izmantojot grafisko \textit{gnome-disks} programmu. Programmā izvēloties ievietoto SD karti, iespējams izmantot \textit{Restore Disk Image} funkciju, lai uzstādītu izvēlēto operētājsistēmas attēlu.
Ja grafiskā vide attēla uzstādīšanai nav pieejama, iespējams izmantot komandrindas rīkus, kas aprakstīta \url{https://www.raspberrypi.org/documentation/installation/installing-images/linux.md} saitē.

\subsubsection{Operētājsistēmas konfigurēšana}
Uzstādīto operētājsistēmu ir iespējams konfigurēt iepriekš pieslēdzot HDMI kabeli pieslēdzot monitoru pie RaspberryPi, kā arī pievienojot tastatūru un tad ieslēdzot iekārtu. Tas ir variants, kā veikt konfigurāciju, ja nav iespējams RaspberryPi pievienot tīklam. Toties, tā kā uz tā tiks uzstādīts serveris, RaspberryPi tika pievienots tīklam un tad tik veikta konfigurēšana izmantojot SSH.
Pievienojot RaspberryPi lokālajā tīklā, pie tā ir iespējams pieslēgties ar noklusējuma pierakstīšānās informāciju.
\begin{lstlisting}
	ssh pi@raspberrypi.local
\end{lstlisting}
Kā redzams, pēc noklusējuma ir izveidots \textit{pi} lietotājs uz \textit{raspberrpi}, kas ir resursdatora nosaukums (angl. \textit{hostname}). Ievadot noklusējuma paroli kas ir \textit{raspberry} ir iespējams pieslēgties RaspberryPi caur SSH.
Tālāk nepieciešamo konfigurāciju ir viegli veikt ar šādu komandu:
\begin{lstlisting}
	sudo raspi-config
\end{lstlisting}
Izvēloties \textit{Expand Filesystem}, iespējams nodrošināt, ka operētājsistēmai tiks dota piekļuve visai brīvajai SD kartes atmiņai. Tika nomainīta noklusētā lietotāja parole, kā arī zem \textit{Advanced Options} tika nomainīts pēc noklusējuma uzstādītais \textit{hostname}.
% Ieteicams arī atvērt \textit{Internationalisation Options}, izvēlēties \textit{Change Locale} un apstiprināt noklusējuma uzstādījumus. Tādejādi tik uzstādīta noklusējuma lokalizācija, ka palīdzēs atbrīvoties no brīdinājumiem izpildot dažādas komandas.
Lai pielāgotu šīs izmaiņas, sistēma tika pārstartēta.

\subsubsection{Sagatavošana darbam ar Chef}
Atkārtoti pieslēdzoties serverim tika veikta Ruby programmēšanas valodas uzstādīšana un Chef klienta uzstādīšana izmantojot RubyGems.
\begin{lstlisting}
	sudo apt-get update
	sudo apt-get install -y ruby ruby-dev
	sudo gem install rack chef --no-document
\end{lstlisting}
Parasti Chef pats uzstādītu jaunāko atbalstīto Chef klientu kad tiktu veikta \textit{knife bootstrap} komanda, izmantojot pieejamos izpildfailus no \url{https://downloads.chef.io/chef-client/}, bet tie nav atbalstīti ARM arhitektūrai. Tāpēc Chef klientu nepieciešams uzstādīt iepriekš. Chef spēj strādāt uz jebkādas arhitektūras, uz kuras atrodas atbilstoša Ruby versija. Tāpēc nepiešamos Chef izpildfailus ir iespējams uzstādīt izmantojot RubyGems. Šī konfigurācija nodrošina, ka RaspberryPi ir sagatavots, lai tā konfigurāciju turpmāk varētu veikt izmantojot Chef.

Protams, visa šī konfigurācija varēja tikt aprakstīta ar Chef. Ir iespējams \textit{knife bootstrap} komandu paplašināt, norādot tai skriptu, kas jāizpilda pirms tiek pielāgota nepieciešamā konfigurācija. Skriptā varētu norādīt nepieciešamās komandas Chef klienta uzstādīšanai, tādejādi ļaujot automatizēt visu veicamo konfigurāciju, kas veicama pēc RaspberryPi ieslēgšanas.

% \textit{Gems} ir Ruby bibliotēkas kurām

\section{Darbs ar Chef bez Chef servera}
Tā kā darbā paredzēts uzstādīt tikai vienu instanci, tika apskatīts kā izmantot Chef sniegtās iespējas arī bez Chef servera. Ir pieejami divi varianti, kā piemērot Chef receptes nekontaktējoties ar Chef serveri. Iespējams izmantot chef-zero vai chef-solo.
Kā priekšnosacījums darbam ar Chef ir izstrādātāja darbstacijas sagatavošana, kas apskatīta \ref{ChefDarbstacija} nodaļā.
\subsubsection{Darbs ar Chef-zero}
Izmantojot \textit{chef-zero}, ir iespējams simulēt pagaidu Chef serveri datora atmiņā. Šo vēl vairāk atvieglo Knife-zero spraudnis (angl. \textit{plugin} \url{https://knife-zero.github.io/}), ar kura palīdzību var izdarīt tās pašas darbības, kā tad, ja ir uzstādīts Chef serveris.
Pēc tam konsolē var izpildīt sekojošas komandas:
\begin{lstlisting}[language=bash]
	chef gem install knife-zero
	chef generate repo test-repo
	cd test-repo
	chef generate cookbook cookbooks/testbook -b
	cd cookbooks/test-book
	berks vendor ../
	knife bootstrap IP_ADDRESS --local-mode --ssh-user vagrant --ssh-password 'vagrant' --sudo --use-sudo-password --run-list 'recipe[testbook]' --node-name chefnode
\end{lstlisting}
Karogs "-b" pie \textit{chef generate cookbook} komandas norāda, ka tiks uzstādīts Berkshelf integrācija, kas ļauj ērti atrisināt recepšu grāmatu atkarības.
Izmantojot \textit{berks vendor} komandu, Berkshelf lejuplādēs visas recepšu grāmatas, kuras ir nepieciešamas infrastruktūras uzstādīšanai.
Komanda \textit{knife bootstrap} veic vairākas darbības. Pirmkārt, tā uzstāda Chef klientu uz norādītās darbstacijas, otrkārt, tā uzstāda norādītās receptes.
Komandas \textit{knife bootstrap} karogu un mainīgo skaidrojums:
\begin{itemize}
	\item IP_ADDRESS -- pārvaldāmās darbstacijas IP adrese
	\item \texttt{--local-mode} -- norāda, ka darbs notiks ar Chef-zero
	\item \texttt{--ssh-user} -- SSH lietotāja vārds, ar kuru pieslēgsies
	\item \texttt{--ssh-password} -- SSH lietotāja parole, to nenorādot, tā tiktu pieprasīta komandas izpildes laikā
	\item \texttt{--use-sudo-password} -- Chef veic darbības kā root lietotājs, tāpēc nepieciešams izmantot lietotāju ar sudo tiesībām
	\item \texttt{--run-list} -- norāda kuras receptes tiks piemērotas pārvaldamajam mezglam
	\item \texttt{--node-name} -- mezgla nosaukums
\end{itemize}

\subsubsection{Lietojot Chef-solo}
Līdzīgi kā Chef-zero, Chef-solo ir vēl viens veids kā piemērot receptes iekārtām bez Chef servera. Chef-solo spēj piemērot receptes, kuras atrodas uz iekārtas.
\begin{itemize}
	\item Uz izstrādātāja darbstacijas lejuplādē visas recepšu grāmatas izmantojot berks vendor
	\item Uzstāda chef-client uz mezgla
	\item Nokopē uzstādāmās recepšu grāmatas uz /var/chef/cookbooks
	\item Izpilda \texttt{chef-solo --override-runlist RUNLIST}
\end{itemize}
Chef-solo komandas --override-runlist karogs nodefinē izpildāmās receptes.

\subsubsection{Hosted Chef}
Strādāt bez Chef servera nav tik viegli. Ar abiem iepriekšminētajiem variantiem ir problēmas, kuras var rasties un var nebūt nemaz tik viegli atrisināmas.
Tāpēc darba izstrādes laikā izmantots \textit{Hosted Chef}, kas ir vienkāršākais veids, kā sākt strādāt ar Chef.
Izveidojot kontu \url{https://manage.chef.io/}, ir iespējams ielogoties grafiskā Chef pārvaldības konsolē.
Pirmais, ko tajā nepieciešams izdarīt ir izveidot jaunu organizāciju. Tad ir iespējams lejuplādēt sākuma paku (angl. \textit{starter kit}), kas ir sagatavots Chef repozitorijs ar nepieciešamo Chef konfigurāciju. Chef servera organizācijās ir arī vairākas noklusējuma grupas (administratori, klienti, lietotāji), kuras tiek izmantotas, lai pārvaldītu izstrādātāju piekļuvi. Kā arī organizācijas satur uzstādītos Chef mezglus. Chef repozitorijā ir slēptā \textit{.chef} mape, kura satur \textit{knife.rb} datni, kurā ir norādīta Chef servera organizācijas adrese.

\section{Mājaslapas izstrāde}
Darba izstrāde tika balstīta uz Agile izstrādes modeli. Sākumā tika noteiktas minimālās "klienta" prasības, veikti mājaslapas un datubāzes struktūres uzmetumi. Notika regulāras tikšanās un prasības tika pastāvīgi papildinātas, gan no "klienta", gan no izstrādātāja puses ieteikumu veidā.

Mājaslapas izstrādē izmantoti šādi rīki:
\begin{itemize}
	\item Ruby on Rails tīmekļa lietojumprogrammu satvars.
	\item CSS -- Bootstrap satvars
	\item JavaScript -- jQuery
	\item Testēšana -- RSpec, Shoulda matchers, Factory Girl, Faker
	\item TravisCI -- CI serviss
	\item Codacy -- statiskas koda analīzes serviss
\end{itemize}

\subsection{Ruby on Rails}
Mājaslapas izstrādē izmantots Ruby on Rails tīmekļa lietojumprogrammu satvars, kas būtiski atvieglo spējīgu mājaslapu izstrādi.
Izmantojot Rails ir iespējams loti ātri izveidot funkcionējošu tīmekļa aplikāciju. Ir iespējams iegūt ļoti daudz funkcionalitātes izmantojot ģeneratorus.
Darba sākumā tika veikta mājaslapas projekta ģenerēšana un repozitorija inicializācija veicot šādas komandas:
\begin{lstlisting}
	rails new access_page
	git init
\end{lstlisting}

Turpmāk tika veiktas izmaiņas \textit{Gemfile} un \textit{.gitignore} failos. \textit{Gemfile} satur nepieciešamo bibliotēku sarakstu, \textit{.gitignore} satur ignorējamo failu sarakstu, kurus nav nepieciešams saglabāt VCS.
Darbā izveidoto \textit{Gemfile} failu iespējams apskatīt \ref{appcode:gemfile} pielikumā. Izveidoto \textit{.gitignore} failu iespējams apskatīt \ref{appcode:gitignore} pielikumā.
Viena no svarīgākājām bibliotēkām, kas atrodama \textit{Gemfile}, ir \textit{bcrypt} bibliotēka, kas nodrošina paroļu drošu glabāšanu datubāzē šifrētā veidā.

Turpinot, tika veikta bibliotēku instalēšana un RSpec uzstādīšana, izpildot šādas komandas uzģenerētajā projekta direktorijā:
\begin{lstlisting}
	bundle install
	rails generate rspec:install
\end{lstlisting}

Nākamais solis bija sagatavot datubāzi. Datubāzes tabulu izveidošanai iespējams izmantot Rails modeļu ģeneratoru. Sākumā tika uzģenerētas divas datubāzes tabulas, viena lietotājiem, viena žurnāliem, izpildot šādas komandas:
\begin{lstlisting}
	rails generate model User name:string surname:string person_code:string password_digest:string level:integer
	rails generate model Log user:references
\end{lstlisting}
Šādi tika uzģenerēta lietotāju tabula ar sākumā nepieciešamajām kolonnām, ieskaitot \textit{password_digest} kolonnu, kas nepieciešama šifrētās paroles glabāšanai. Kā arī tika uzģenerēta žurnālu kolonna ar ārējo atslēgu (angl. \textit{foreign key}) norādot uz lietotāju ID. Rails automātiski parūpējas par ID, kā arī izveidošanas un labošanas laika zīmogu (angl. \textit{timestamp}) kolonnu izveidošanu un tās ģeneratoram nav jānorāda.
% Uzzīmēt datubāzes struktūru.

Kontrolieros tiek aprakstīta tīmekļa aplikācijas darbības loģika. Darba sākumā tika uzģenerēti četri kontrolieri.
\begin{lstlisting}
	rails generate controller Home index
	rails generate controller Users index new show edit
	rails generate controller Sessions new
	rails generate controller Reader
\end{lstlisting}
Ģeneratoram nepieciešams norādīt tikai kontroliera nosaukumu, bet iespējams norādīt vēl papildus argumentus - kontroliera rīcības (angl. \textit{action}). Tās ir metodes, kurās veikt funkcionalitātes programmēšanu. Norādot tās ģeneratoram tiks uzģenerētas arī skatu sagataves, kurās veikt mājaslapas izstrādi. Kontrolieri tiek rakstīti izmantojot Ruby programmēšanas valodu, bet skati tiek veidoti izmantojot HTML un arī iegultu Ruby kodu (angl. \textit{embedded Ruby}), attiecīgi tāpēc to failu paplašinājums ir .html.erb. Attiecīgi, uzģenerētais lietotāju kontrolieris sagatavo četrus skatus un četras metodes. \textit{Index} metode un skats izmantota, lai attēlotu visus sistēmā esošos lietotājus, \textit{new} - lai pievienotu jaunu lietotāju, \textit{show} - lai attēlotu visu pieejamo informāciju par vienu lietotāju, \textit{edit} - lai labotu esošu lietotāju.

Norādot kontrolieru ģeneratoram vairākas rīcības, tas ne tikai sagatavos kontrolieri ar metodēm, skatus, bet arī parūpēsies par maršrutu izveidošanu. Rails maršrutēšana tiek veikta attiecinot URL uz kodu. Attiecīgi maršruts \textit{/users/new} izmanto tāda paša nosaukuma skatu un to apstrādā izmantojot \textit{users} kontroliera \textit{new} metodi. Rails arī piedāvā saīsinātu veidu, kā aprakstīt REST ceļus.
\begin{lstlisting}
	resources :users
\end{lstlisting}
% Ievietojot šādu rindu projekta \textit{config/routes.rb} failā, būs pieejami septiņi ceļi, kas norādīs uz septiņām kontroliera metodēm un izmantos kādu no HTTP darbības vārdiem (GET, POST, PUT, DELETE).
% \begin{lstlisting}
% 			users GET    /users(.:format)          users#index
% 						POST   /users(.:format)          users#create
% 	 new_user GET    /users/new(.:format)      users#new
% 	edit_user GET    /users/:id/edit(.:format) users#edit
% 			 user GET    /users/:id(.:format)      users#show
% 						PUT    /users/:id(.:format)      users#update
% 						DELETE /users/:id(.:format)      users#destroy
% \end{lstlisting}

Rails ir ļoti parocīgs Agile tipa izstrādei, jo viegli ļauj aplikāciju papildināt ar jaunu funkcionalitāti. Darba gaitā radās papildus prasības un bija nepieciešams papildināt esošās datubāzes tabulas ar papildus kolonnām, kā arī bija jāizveido jauna tabula un kontrolieris. Jaunu tabulu izveidošana notiek tieši tā pat kā iepriekš - uzģenerējot modeli. Esošu tabulu mainīšanai iespējams izmantot migrāciju ģeneratoru.
\begin{lstlisting}
	rails generate migration add_email_phone_card_id_to_user email:string phone:string card_id:string
	rails generate migration add_timeopen_timeclose_action_reason_to_log timeopen:datetime timeclose:datetime action:integer reason:string
	rails generate model Box category:integer email:string content:text
	rails generate controller Box index new show edit
	rails generate migration add_title_to_box title:string
\end{lstlisting}
Ģenerējot migrācijas ir būtiski ievērot to nosaukumu. Migrācijas nosaukuma sākumā jānorāda veicamā darbība - pievienošana (\textit{add}) vai atņemšana (\textit{remove}), beigās norādot eksistējošu modeli kā redzams komandās, kuram tiks piemērota norādītā darbība. Piemēram, \textit{add_title_to_box} pievienos virsraksta kolonnu \textit{box} modelim.


Veicot jebkādas datubāzes struktūras izmaiņas, ģenerējot jaunus modeļus vai migrācijas, jāatceras tās piemērot izmantojot komandu:
\begin{lstlisting}
	rake db:migrate
\end{lstlisting}

\subsubsection{Bootstrap}
Darbā izmantots Bootstrap CSS satvars (\url{http://getbootstrap.com/}), kas ļauj ātri izveidot pieņemamas, arī mobilām iekārtām piemērotas mājaslapas.
Bootstrap ir iespējams pievienot Rails aplikācijai vairākos veidos. Viens no veidiem ir pievienot to \textit{Gemfile}, kā bibliotēku. Tomēr tādu variantu neizvēlējos, jo tādejādi mājaslapas lietotājam būtu jālejuplādē Bootstrap CSS faili no uzstādītā servera, kā arī tas nav nepieciešams, ja negrasās ievērojami konfigurēt Bootstrap CSS klases.
Tā kā darbā nav paredzēts izmainīt Bootstrap klases, tas pievienots izmantojot satura piegādes tīklu (angl. \textit{content delivery network}) jeb \textit{CDN}, kas nodrošina augstu pieejamību CSS failiem. Kā arī, daudzas populāras mājaslapas izmanto Bootstrap, tādejādi ir iespējams, ka izveidotās mājaslapas lietotājiem, nepieciešamais CSS fails atrastos pārlūka kešatmiņā.
\begin{lstlisting}[language=HTML]
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
\end{lstlisting}

\subsubsection{jQuery}
Mājaslapai ir nepieciešams \textit{jQuery} JavaScript satvars, lai nodrošinātu lietotāju žurnālu kārtošanu pēc datubāzes kolonnām. Izmantojot \textit{jQuery} \textit{tablesorter} spraudni (\url{https://mottie.github.io/tablesorter/docs/index.html}), tiek nodrošināta parādīto ierakstu kārtošana, atvieglojot sistēmas administrēšanu.

\subsection{Testēšana} \label{Testing}

\subsubsection{Codacy}
Codacy ir viens no statiskas koda analīzes servisiem, kas pieejams par brīvu atvērtā koda projektiem, kā arī ir viegli integrējams ar GitHub (\url{https://github.com/integrations}). Statiska koda analīze spēj atklāt vairākas lietas neizpildot kodu.
Piemēram, iespējams atklāt:
\begin{itemize}
	\item koda stila kļūdas, kas parasti izveidojas nesekojot vispār pieņemtai konvencijai, tādejādi apgrūtinot koda lasāmību;
	\item neizmantotu kodu;
	\item drošības riskus, piemēram, SQL injekcijas iespējas;
\end{itemize}
Statiska koda analīze spēj atklāt un izvairīties no zināmu sliktu paņēmienu izmantošanas, nodrošinot augstāku koda kvalitāti. Kvalitatīvs kods ir vieglāk lasāms un tādejādi arī vieglāk uzturams un atbalstāms.

\subsubsection{TravisCI}
TravisCI arī ir viens no rīkiem, kas ir viegli integrējams ar GitHub.
\begin{lstlisting}
	language: ruby
	rvm:
	  - 2.2.3
	bundler_args: --without production
	env:
	  - DB=sqlite
	script:
	  - RAILS_ENV=test bundle exec rake --trace db:migrate test
	  - bundle exec rspec
	notifications:
	  email: false
\end{lstlisting}

\subsubsection{RSpec}
RSpec jeb RubySpec ir populārākā Ruby testēšanas bibliotēka. RSpec tika izdots 2005. gadā.
\cite{shayRspec}
RSpec ir BDD testēšanas satvars. RSpec izmanto savu DSL, kas līdzinās dabiskas valodas specifikācijai. Lasot RSpec testus tiem būtu jāizklausās pēc normāliem teikumiem. Tā RSpec cenšas testus padarīt lasāmus un saprotamus.
\subsubsection{Shoulda matchers}
\subsubsection{Factory Girl}
\subsubsection{Faker}

\subsection{Lietotāji}
\subsection{Uzbrukumi}